<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>GDACS Map with Weather, Event & Facility Data</title>
    <!-- Include React, ReactDOM, Babel, and Tailwind CSS -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <!-- <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      /* Map container style: fixed height to ensure markers are visible */
      #map {
        width: 100%;
        height: 400px;
      }
      /* Loader style */
      .loader {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
        display: inline-block;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      /* Legend styling */
      .legend {
        background: white;
        padding: 10px;
        line-height: 1.5;
        color: #333;
      }
      /* Status log styling */
      .status-log {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        padding: 10px;
        max-height: 200px;
        overflow-y: auto;
        font-family: monospace;
        white-space: pre-wrap;
      }
      /* Table styling */
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        border: 1px solid #e2e8f0;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f3f4f6;
      }
    </style>
  </head>
  <body class="bg-gray-50">
    <div id="root" class="p-4 max-w-6xl mx-auto"></div>
    <!-- Include Leaflet JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <!-- Our App Code -->
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      function App() {
        // ----- SETTINGS STATE -----
        // OpenAI API settings (for GDACS extraction and event summaries)
        const [apiKey, setApiKey] = useState(localStorage.getItem('openai_api_key') || '');
        const [apiModel, setApiModel] = useState(localStorage.getItem('api_model') || 'o3-mini');
        const [modelEffort, setModelEffort] = useState(localStorage.getItem('model_effort') || 'medium');

        // Weather API key, weather layer enable toggle, and multi-select weather layer options.
        const [weatherApiKey, setWeatherApiKey] = useState(localStorage.getItem('weather_api_key') || '');
        const [weatherLayerEnabled, setWeatherLayerEnabled] = useState(
          localStorage.getItem('weather_layer_enabled') === 'true' || false
        );
        const [selectedWeatherLayers, setSelectedWeatherLayers] = useState(() => {
          const saved = localStorage.getItem('weather_layer_options');
          return saved ? JSON.parse(saved) : [];
        });

        const [showSettings, setShowSettings] = useState(false);
        const [statusMsg, setStatusMsg] = useState('');

        // ----- DATA STATES -----
        // GDACS extracted event data
        const [extractedData, setExtractedData] = useState([]);
        const [loading, setLoading] = useState(false);
        // Facilities data loaded via CSV upload
        const [facilitiesData, setFacilitiesData] = useState([]);

        // New state: facility summaries generated by GPT for affected facilities.
        const [facilitySummaries, setFacilitySummaries] = useState([]);

        // ----- MAP REFERENCES -----
        const mapRef = useRef(null);
        const markerLayerRef = useRef(null);
        // For weather layers, we store an array of layers.
        const weatherLayersRef = useRef([]);

        // ----- ICON MAPPINGS -----
        const iconMapping = {
          "EQ": L.icon({
            iconUrl: "https://www.gdacs.org/Images/gdacs_icons/alerts/Green/EQ.png",
            iconSize: [30, 30],
            iconAnchor: [15, 30],
            popupAnchor: [0, -30]
          }),
          "FL": L.icon({
            iconUrl: "https://www.gdacs.org/Images/gdacs_icons/alerts/Green/FL.png",
            iconSize: [30, 30],
            iconAnchor: [15, 30],
            popupAnchor: [0, -30]
          }),
          "VO": L.icon({
            iconUrl: "https://www.gdacs.org/Images/gdacs_icons/alerts/Green/VO.png",
            iconSize: [30, 30],
            iconAnchor: [15, 30],
            popupAnchor: [0, -30]
          }),
          "TC": L.icon({
            iconUrl: "https://www.gdacs.org/Images/gdacs_icons/alerts/Green/TC.png",
            iconSize: [30, 30],
            iconAnchor: [15, 30],
            popupAnchor: [0, -30]
          }),
          "DR": L.icon({
            iconUrl: "https://www.gdacs.org/Images/gdacs_icons/alerts/Green/DR.png",
            iconSize: [30, 30],
            iconAnchor: [15, 30],
            popupAnchor: [0, -30]
          }),
          default: L.icon({
            iconUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png",
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowUrl: "https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png",
            shadowSize: [41, 41]
          })
        };

        // Facility icons
        const facilityIconUnaffected = L.icon({
          iconUrl: "https://maps.google.com/mapfiles/ms/icons/blue-dot.png",
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        });
        const facilityIconAffected = L.icon({
          iconUrl: "https://maps.google.com/mapfiles/ms/icons/red-dot.png",
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        });

        // ----- MAP INITIALIZATION -----
        useEffect(() => {
          if (mapRef.current) return; // Prevent reinitialization
          mapRef.current = L.map('map').setView([20, 0], 2);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data © OpenStreetMap contributors'
          }).addTo(mapRef.current);
          markerLayerRef.current = L.layerGroup().addTo(mapRef.current);

          // Add legend control with explicit inline CSS for icons.
          const legend = L.control({ position: 'bottomright' });
          legend.onAdd = function () {
            const div = L.DomUtil.create('div', 'legend');
            div.innerHTML = `<strong>Legend</strong><br>
              <i style="background: url('https://www.gdacs.org/Images/gdacs_icons/alerts/Green/EQ.png'); background-size: cover; width: 20px; height: 20px; display: inline-block; background-repeat: no-repeat; margin-right: 5px;"></i> Earthquake<br>
              <i style="background: url('https://www.gdacs.org/Images/gdacs_icons/alerts/Green/FL.png'); background-size: cover; width: 20px; height: 20px; display: inline-block; background-repeat: no-repeat; margin-right: 5px;"></i> Flood<br>
              <i style="background: url('https://www.gdacs.org/Images/gdacs_icons/alerts/Green/VO.png'); background-size: cover; width: 20px; height: 20px; display: inline-block; background-repeat: no-repeat; margin-right: 5px;"></i> Volcano<br>
              <i style="background: url('https://www.gdacs.org/Images/gdacs_icons/alerts/Green/TC.png'); background-size: cover; width: 20px; height: 20px; display: inline-block; background-repeat: no-repeat; margin-right: 5px;"></i> Tropical Cyclone<br>
              <i style="background: url('https://www.gdacs.org/Images/gdacs_icons/alerts/Green/DR.png'); background-size: cover; width: 20px; height: 20px; display: inline-block; background-repeat: no-repeat; margin-right: 5px;"></i> Drought<br>
              <i style="background: url('https://maps.google.com/mapfiles/ms/icons/blue-dot.png'); background-size: cover; width: 20px; height: 20px; display: inline-block; background-repeat: no-repeat; margin-right: 5px;"></i> Facility (Unaffected)<br>
              <i style="background: url('https://maps.google.com/mapfiles/ms/icons/red-dot.png'); background-size: cover; width: 20px; height: 20px; display: inline-block; background-repeat: no-repeat; margin-right: 5px;"></i> Facility (Affected)`;
            return div;
          };
          legend.addTo(mapRef.current);
        }, []);

        // ----- WEATHER LAYER CONTROL (Multi-Select) -----
        useEffect(() => {
          // Remove any existing weather layers.
          weatherLayersRef.current.forEach(layer => mapRef.current.removeLayer(layer));
          weatherLayersRef.current = [];
          if (weatherLayerEnabled && weatherApiKey.trim() && selectedWeatherLayers.length > 0) {
            selectedWeatherLayers.forEach(option => {
              const weatherURL = "https://tile.openweathermap.org/map/" + option + "/{z}/{x}/{y}.png?appid=" + weatherApiKey.trim();
              const layer = L.tileLayer(weatherURL, { attribution: 'Map data © OpenWeatherMap' });
              layer.addTo(mapRef.current);
              weatherLayersRef.current.push(layer);
            });
          }
        }, [weatherLayerEnabled, weatherApiKey, selectedWeatherLayers]);

        // ----- CLICK HANDLER FOR WEATHER POPUP -----
        useEffect(() => {
          if (!mapRef.current) return;
          mapRef.current.on('click', async (e) => {
            if (!weatherApiKey.trim()) {
              console.log("No Weather API key provided.");
              return;
            }
            const { lat, lng } = e.latlng;
            try {
              const weatherRes = await fetch(
                `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${weatherApiKey.trim()}&units=metric`
              );
              if (!weatherRes.ok) {
                throw new Error("Failed to fetch weather data.");
              }
              const weatherData = await weatherRes.json();
              const content = `
                <strong>Weather Info</strong><br>
                Location: ${weatherData.name || 'N/A'}<br>
                Temperature: ${weatherData.main?.temp} °C<br>
                Conditions: ${weatherData.weather?.[0]?.description || 'N/A'}<br>
                Humidity: ${weatherData.main?.humidity} %`;
              L.popup().setLatLng(e.latlng).setContent(content).openOn(mapRef.current);
            } catch (err) {
              console.error("Error fetching weather info:", err);
            }
          });
          return () => {
            if (mapRef.current) {
              mapRef.current.off('click');
            }
          };
        }, [weatherApiKey]);

        // ----- UPDATE MARKERS (Events & Facilities) -----
        useEffect(() => {
          if (!mapRef.current) return;
          const updateMarkers = () => {
            markerLayerRef.current.clearLayers();

            // Add event markers from extractedData.
            extractedData.forEach(item => {
              if (item.latitude && item.longitude) {
                const typeKey = item.type ? item.type.toUpperCase().trim() : "default";
                const icon = iconMapping[typeKey] || iconMapping.default;
                let popupContent = `<strong>${item.title}</strong><br>Type: ${item.type}`;
                if (item.date) popupContent += `<br>Date: ${item.date}`;
                if (item.magnitude) popupContent += `<br>Magnitude: ${item.magnitude}`;
                if (item.description) popupContent += `<br>${item.description}`;
                L.marker([item.latitude, item.longitude], { icon })
                  .addTo(markerLayerRef.current)
                  .bindPopup(popupContent);
                if (typeKey === "TC" && Array.isArray(item.path)) {
                  L.polyline(item.path, { color: 'red', weight: 3 }).addTo(markerLayerRef.current);
                }
                if (Array.isArray(item.affectedArea)) {
                  L.polygon(item.affectedArea, { color: 'orange', fillOpacity: 0.3 })
                    .addTo(markerLayerRef.current)
                    .bindPopup(`<strong>Affected Area</strong> for ${item.title}`);
                }
                if (item.impactRadius && typeof item.impactRadius === 'number') {
                  L.circle([item.latitude, item.longitude], {
                    radius: item.impactRadius,
                    color: 'purple',
                    fillOpacity: 0.2
                  }).addTo(markerLayerRef.current);
                }
              }
            });

            // Add facility markers from facilitiesData.
            facilitiesData.forEach(facility => {
              if (facility.latitude && facility.longitude) {
                const lat = parseFloat(facility.latitude);
                const lng = parseFloat(facility.longitude);
                const affectedEvents = extractedData.filter(event => isFacilityAffected(facility, event));
                const icon = affectedEvents.length > 0 ? facilityIconAffected : facilityIconUnaffected;
                let basePopup = `<strong>${facility.name}</strong>`;
                if (affectedEvents.length > 0) {
                  basePopup += `<br>Affected by: ${affectedEvents.map(e => e.title).join(', ')}`;
                } else {
                  basePopup += `<br>Not affected by any events.`;
                }
                const marker = L.marker([lat, lng], { icon }).addTo(markerLayerRef.current);
                marker.bindPopup(basePopup);
                // If affected by a flood event, add a click handler to generate a summary.
                if (affectedEvents.some(e => e.type && e.type.toUpperCase().includes("FL"))) {
                  marker.on('click', async () => {
                    const floodEvents = affectedEvents.filter(e => e.type && e.type.toUpperCase().includes("FL"));
                    const prompt = `Provide a concise disaster event summary for a flood affecting the facility "${facility.name}" located at [${lat}, ${lng}]. Include key details such as severity, location, and impact, and suggest potential response actions. Use these event details: ${JSON.stringify(floodEvents)}.`;
                    console.log("Generating summary with prompt:", prompt);
                    try {
                      const summary = await callGPTSummary(prompt);
                      console.log("Generated summary:", summary);
                      // Instead of a popup, update the facilitySummaries table.
                      setFacilitySummaries(prev => {
                        const filtered = prev.filter(f => f.name !== facility.name);
                        return [...filtered, { name: facility.name, lat, lng, summary }];
                      });
                    } catch (error) {
                      console.error("Error generating summary:", error);
                    }
                  });
                }
              }
            });
          };

          updateMarkers();
          mapRef.current.off('zoomend moveend', updateMarkers);
          mapRef.current.on('zoomend moveend', updateMarkers);
          return () => {
            mapRef.current.off('zoomend moveend', updateMarkers);
          };
        }, [extractedData, facilitiesData]);

        // ----- HELPER FUNCTIONS -----
        function pointInPolygon(point, vs) {
          const x = point[0], y = point[1];
          let inside = false;
          for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            const xi = vs[i][0], yi = vs[i][1];
            const xj = vs[j][0], yj = vs[j][1];
            const intersect = ((yi > y) !== (yj > y)) &&
                              (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
          }
          return inside;
        }
        function isFacilityAffected(facility, event) {
          const lat = parseFloat(facility.latitude);
          const lon = parseFloat(facility.longitude);
          if (event.impactRadius && typeof event.impactRadius === 'number') {
            const distance = getDistance(lat, lon, parseFloat(event.latitude), parseFloat(event.longitude));
            if (distance <= event.impactRadius) return true;
          }
          if (Array.isArray(event.affectedArea)) {
            if (pointInPolygon([lat, lon], event.affectedArea)) return true;
          }
          return false;
        }
        function getDistance(lat1, lon1, lat2, lon2) {
          const R = 6371000;
          const rad = Math.PI / 180;
          const dLat = (lat2 - lat1) * rad;
          const dLon = (lon2 - lon1) * rad;
          const a = Math.sin(dLat / 2) ** 2 +
                    Math.cos(lat1 * rad) * Math.cos(lat2 * rad) *
                    Math.sin(dLon / 2) ** 2;
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        // Function to call GPT for generating an automated summary.
        async function callGPTSummary(prompt) {
          const requestBody = {
            model: apiModel,
            messages: [
              { role: "system", content: "You are a helpful assistant that summarizes disaster events." },
              { role: "user", content: prompt }
            ]
          };
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${apiKey.trim()}`
            },
            body: JSON.stringify(requestBody)
          });
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || "API request failed");
          }
          const data = await response.json();
          return data.choices[0].message.content.trim();
        }

        // ----- SETTINGS SAVE -----
        const saveSettings = () => {
          localStorage.setItem('openai_api_key', apiKey);
          localStorage.setItem('api_model', apiModel);
          localStorage.setItem('model_effort', modelEffort);
          localStorage.setItem('weather_api_key', weatherApiKey);
          localStorage.setItem('weather_layer_enabled', weatherLayerEnabled);
          localStorage.setItem('weather_layer_options', JSON.stringify(selectedWeatherLayers));
          setShowSettings(false);
        };

        // ----- WEATHER LAYER MULTI-SELECT HANDLER -----
        function toggleWeatherLayer(option) {
          setSelectedWeatherLayers(prev => {
            if (prev.includes(option)) {
              return prev.filter(o => o !== option);
            } else {
              return [...prev, option];
            }
          });
        }

        // ----- API CALL & XML EXTRACTION -----
        async function makeApiCall(prompt, xmlText) {
          const requestBody = {
            model: apiModel,
            messages: [
              { role: "system", content: prompt },
              { role: "user", content: xmlText }
            ]
          };
          if (apiModel === "o3-mini") {
            requestBody.reasoning_effort = modelEffort;
          }
          setStatusMsg("Calling OpenAI API...");
          const response = await fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${apiKey.trim()}`
            },
            body: JSON.stringify(requestBody)
          });
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || "API request failed");
          }
          const data = await response.json();
          const content = data.choices[0].message.content.trim();
          return content;
        }
        async function loadAndExtract() {
          setLoading(true);
          setStatusMsg("Loading XML file...");
          try {
            const res = await fetch('gdacs_feed.xml');
            if (!res.ok) throw new Error("Failed to load XML file");
            const xmlText = await res.text();
            const prompt = `Extract the following information from the provided XML feed.
For each <item> element, extract:
- title
- latitude
- longitude
- event type (from the <gdacs:eventtype> element)
For tropical cyclone events (event type "TC"), also extract the cyclone path as an array of coordinate pairs in the format [[lat, lon], [lat, lon], ...].

If available, also extract additional details such as:
- date
- magnitude
- description
- affected area as an array of coordinate pairs (for a polygon)
- impact radius in meters

Return only the JSON array, for example:
[{"title": "Event Title", "latitude": 0.0, "longitude": 0.0, "type": "TC", "date": "YYYY-MM-DD", "magnitude": "X.X", "description": "Some details", "path": [[lat, lon], ...], "affectedArea": [[lat, lon], ...], "impactRadius": 5000}, ...]`;
            setStatusMsg("Extracting data via OpenAI...");
            const resultText = await makeApiCall(prompt, xmlText);
            console.log("Raw API response:", resultText);
            const startIndex = resultText.indexOf('[');
            if (startIndex === -1) {
              throw new Error("Could not locate JSON array in the API response");
            }
            const jsonText = resultText.substring(startIndex);
            const jsonData = JSON.parse(jsonText);
            setExtractedData(jsonData);
            setStatusMsg("Extraction complete!");
          } catch (err) {
            console.error("Error during extraction:", err);
            setStatusMsg("Error: " + err.message);
          }
          setLoading(false);
        }

        // ----- CSV UPLOAD & PARSING -----
        function parseCSV(csvText) {
          const lines = csvText.trim().split("\n");
          const headers = lines[0].split(",").map(h => h.trim());
          const data = lines.slice(1).map(line => {
            const values = line.split(",").map(v => v.trim());
            const obj = {};
            headers.forEach((header, idx) => {
              const num = parseFloat(values[idx]);
              obj[header] = isNaN(num) ? values[idx] : num;
            });
            return obj;
          });
          return data;
        }
        function handleCSVUpload(e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function(event) {
            const text = event.target.result;
            const data = parseCSV(text);
            setFacilitiesData(data);
            setStatusMsg("Facility data loaded from CSV.");
          };
          reader.readAsText(file);
        }

        return (
          <div className="space-y-6">
            <div className="flex justify-between items-center mb-4">
              <h1 className="text-2xl font-bold">GDACS Map with Weather, Event & Facility Data</h1>
              <button onClick={() => setShowSettings(true)} className="px-3 py-1 text-gray-600 border rounded hover:bg-gray-50">
                ⚙️ Settings
              </button>
            </div>
            {/* Settings Modal */}
            {showSettings && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" style={{ zIndex: 9999 }}>
                <div className="bg-white p-6 rounded-lg max-w-lg w-full">
                  <h2 className="text-xl font-bold mb-4">Settings</h2>
                  <div className="mb-4">
                    <label className="block mb-1 font-semibold">OpenAI API Key</label>
                    <input type="password" className="w-full p-2 border rounded" value={apiKey} onChange={(e) => setApiKey(e.target.value)} />
                  </div>
                  <div className="mb-4">
                    <label className="block mb-1 font-semibold">API Model</label>
                    <select className="w-full p-2 border rounded" value={apiModel} onChange={(e) => setApiModel(e.target.value)}>
                      <option value="o3-mini">o3-mini</option>
                      <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                      <option value="gpt-4">gpt-4</option>
                    </select>
                  </div>
                  {apiModel === "o3-mini" && (
                    <div className="mb-4">
                      <label className="block mb-1 font-semibold">Reasoning Effort</label>
                      <select className="w-full p-2 border rounded" value={modelEffort} onChange={(e) => setModelEffort(e.target.value)}>
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                      </select>
                    </div>
                  )}
                  <hr className="my-4" />
                  <div className="mb-4">
                    <label className="block mb-1 font-semibold">Weather API Key</label>
                    <input type="password" className="w-full p-2 border rounded" value={weatherApiKey} onChange={(e) => setWeatherApiKey(e.target.value)} />
                  </div>
                  <div className="mb-4">
                    <div className="flex items-center gap-2">
                      <input type="checkbox" checked={weatherLayerEnabled} onChange={(e) => setWeatherLayerEnabled(e.target.checked)} id="weatherToggle" />
                      <label htmlFor="weatherToggle">Enable Weather Layers</label>
                    </div>
                    {weatherLayerEnabled && (
                      <div className="mt-2">
                        <span className="block mb-1 font-semibold">Select Weather Layers:</span>
                        <div className="flex flex-wrap gap-2">
                          {["clouds_new", "precipitation_new", "pressure_new", "wind_new", "temp_new"].map(option => (
                            <label key={option} className="flex items-center gap-1">
                              <input type="checkbox" checked={selectedWeatherLayers.includes(option)} onChange={() => toggleWeatherLayer(option)} />
                              <span>{option.replace("_new", "")}</span>
                            </label>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                  <div className="flex justify-end gap-4">
                    <button onClick={saveSettings} className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                      Save & Close
                    </button>
                  </div>
                </div>
              </div>
            )}
            {/* Map container */}
            <div id="map" className="rounded shadow mb-4"></div>
            {/* Control Panel */}
            <div className="flex flex-col items-center gap-4">
              <button onClick={loadAndExtract} disabled={loading || !apiKey} className="px-6 py-3 bg-green-500 text-white rounded hover:bg-green-600 disabled:bg-gray-400 flex items-center gap-2">
                {loading ? (
                  <>
                    <div className="loader" />
                    <span>Extracting...</span>
                  </>
                ) : (
                  <span>Extract Data from XML</span>
                )}
              </button>
              <div>
                <label className="mr-2 font-semibold">Upload Facilities CSV:</label>
                <input type="file" accept=".csv" onChange={handleCSVUpload} />
              </div>
              {statusMsg && <p className="mt-2 text-sm text-gray-600">{statusMsg}</p>}
            </div>
            {/* Facility Summaries Table */}
            {facilitySummaries.length > 0 && (
              <div className="mt-4">
                <h2 className="text-xl font-bold mb-2">Affected Facilities Summary</h2>
                <table>
                  <thead>
                    <tr>
                      <th>Facility Name</th>
                      <th>Location</th>
                      <th>Summary</th>
                    </tr>
                  </thead>
                  <tbody>
                    {facilitySummaries.map((fac, index) => (
                      <tr key={index}>
                        <td>{fac.name}</td>
                        <td>[{fac.lat}, {fac.lng}]</td>
                        <td>{fac.summary}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        );
      }

      ReactDOM.render(<App />, document.getElementById('root'));
    </script>
  </body>
</html>
